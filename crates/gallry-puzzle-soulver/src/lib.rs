//! Gallary Puzzle Soulver
//! 
//! Each gallery item has a corresponding word of arbitrary length.
//! Each letter in the word has it's own distinct set of 8 possible characters.
//! Produce a list of all the words that can be formed from the letters for a given list of characters and their corresponding possible characters.

use std::ops::Deref;

// Define a slot as a character with a list of possible characters and a selected character.
//
// Dereferencing the slot returns the selected character.
pub struct Slot {
    options: Vec<char>,
    current: usize, // index of the selected character
}

impl Slot {
    pub fn new(options: Vec<char>) -> Self {
        Self { options, current: 0 }
    }
}

impl Into<String> for Slot {
    fn into(self) -> String {
        self.options[self.current].to_string()
    }
}

impl Deref for Slot {
    type Target = char;

    fn deref(&self) -> &Self::Target {
        &self.options[self.current]
    }
}

impl Iterator for Slot {
    type Item = char;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current < self.options.len() {
            let result = Some(self.options[self.current]);
            self.current += 1;
            result
        } else {
            None
        }
    }
}

pub struct WordGenerator {
    slots: Vec<Slot>,
    words: Option<Vec<String>>,
    word_list: Option<Vec<String>>,
}

impl WordGenerator {
    pub fn new(slots: Vec<Slot>, word_list: Option<Vec<String>>) -> Self {
        let word_list = match word_list {
            Some(list) => Some(list),
            None => {
                // Try to read wordlist.txt, but don't panic if it doesn't exist
                std::fs::read_to_string("wordlist.txt")
                    .map(|content| {
                        content.lines()
                              .map(|line| line.to_string())
                              .collect()
                    })
                    .ok()
            }
        };
        
        Self { 
            slots, 
            words: None, 
            word_list
        }
    }

    // Generate words using the current slot values.
    pub fn generate(&mut self) {
        self.words = Some(
            self.slots.iter()
                .map(|slot| slot.options.iter())
                .fold(vec![String::new()], |acc, options| {
                    acc.iter()
                        .flat_map(|prefix| options.clone().map(move |&c| format!("{}{}", prefix, c)))
                        .collect()
                })
        );
    }
    
    // Get the words generated by the generator, filtering out any words that are not present in our word list.
    pub fn get_words(&self) -> Option<Vec<String>> {
        self.words.as_ref().map(|words| {
            match &self.word_list {
                Some(word_list) if !word_list.is_empty() => {
                    // Filter words that exist in the word list
                    words.iter()
                        .filter(|word| word_list.contains(word))
                        .cloned()
                        .collect()
                },
                _ => words.clone() // No filtering required
            }
        })
    }
}
