//! Gallary Puzzle Soulver
//! 
//! Each gallery item has a corresponding word of arbitrary length.
//! Each letter in the word has it's own distinct set of 8 possible characters.
//! Produce a list of all the words that can be formed from the letters for a given list of characters and their corresponding possible characters.

use std::ops::Deref;
use std::collections::HashSet;
use anyhow::{Result, Context};

// Embed the wordlist at compile time
const EMBEDDED_WORDLIST: &str = include_str!("../data/words.txt");

// Define a slot as a character with a list of possible characters and a selected character.
//
// Dereferencing the slot returns the selected character.
pub struct Slot {
    options: Vec<char>,
    current: usize, // index of the selected character
}

impl Slot {
    pub fn new(options: Vec<char>) -> Self {
        Self { options, current: 0 }
    }
}

impl Into<String> for Slot {
    fn into(self) -> String {
        self.options[self.current].to_string()
    }
}

impl Deref for Slot {
    type Target = char;

    fn deref(&self) -> &Self::Target {
        &self.options[self.current]
    }
}

impl Iterator for Slot {
    type Item = char;

    fn next(&mut self) -> Option<Self::Item> {
        if self.current < self.options.len() {
            let result = Some(self.options[self.current]);
            self.current += 1;
            result
        } else {
            None
        }
    }
}

pub struct WordGenerator {
    slots: Vec<Slot>,
    words: Option<Vec<String>>,
    word_list: Option<HashSet<String>>,
}

impl WordGenerator {
    /// Create a new WordGenerator with the given slots and word list
    /// 
    /// If word_list is None, it will use the embedded wordlist
    pub fn new(slots: Vec<Slot>, word_list: Option<HashSet<String>>) -> Self {
        let word_list = match word_list {
            Some(list) => Some(list),
            None => {
                // Use the embedded wordlist
                let word_set: HashSet<String> = EMBEDDED_WORDLIST
                    .lines()
                    .map(|line| line.to_string())
                    .collect();
                
                Some(word_set)
            }
        };
        
        Self { 
            slots, 
            words: None, 
            word_list
        }
    }
    
    /// Create a WordGenerator with the given slots and the default embedded word list
    pub fn with_slots(slots: Vec<Slot>) -> Self {
        Self::new(slots, None)
    }
    
    /// Create a WordGenerator with the given slots and an empty word list
    /// (no word filtering will be applied)
    pub fn with_no_filtering(slots: Vec<Slot>) -> Self {
        Self {
            slots,
            words: None,
            word_list: Some(HashSet::new()),
        }
    }
    
    /// Attempt to load a custom word list from a file at runtime
    pub fn load_word_list_from_file(&mut self, path: &str) -> Result<()> {
        let content = std::fs::read_to_string(path)
            .context(format!("Failed to read word list from {}", path))?;
        
        let word_set: HashSet<String> = content
            .lines()
            .map(|line| line.to_string())
            .collect();
        
        self.word_list = Some(word_set);
        Ok(())
    }

    /// Generate words using the current slot values.
    pub fn generate(&mut self) {
        self.words = Some(
            self.slots.iter()
                .map(|slot| slot.options.iter())
                .fold(vec![String::new()], |acc, options| {
                    acc.iter()
                        .flat_map(|prefix| options.clone().map(move |&c| format!("{}{}", prefix, c)))
                        .collect()
                })
        );
    }
    
    /// Get the words generated by the generator, filtering by the word list if provided
    /// 
    /// Returns an iterator over the filtered words, or None if no words have been generated
    pub fn get_words(&self) -> Option<impl Iterator<Item = String> + '_> {
        self.words.as_ref().map(|words| {
            words.iter().filter_map(move |word| {
                // If we have a non-empty word list, check if the word is in it
                if let Some(word_list) = &self.word_list {
                    if word_list.is_empty() || word_list.contains(word) {
                        Some(word.clone())
                    } else {
                        None
                    }
                } else {
                    // No word list, include all words
                    Some(word.clone())
                }
            })
        })
    }
    
    /// Get all generated words as a Vec without filtering
    pub fn get_all_words(&self) -> Option<&Vec<String>> {
        self.words.as_ref()
    }
    
    /// Update the word list
    pub fn set_word_list(&mut self, word_list: HashSet<String>) {
        self.word_list = Some(word_list);
    }
}
